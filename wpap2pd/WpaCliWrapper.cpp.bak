#include "includes/WpaSupplicant.h"
#include "cotask/Os.h"
#include "cotask/CoEvent.h"
#include "ss.h"

using namespace cotask;
using namespace p2p;
using namespace std;

const char *WPA_CONTROL_SOCKET_DIR = "/var/run/wpa_supplicant";

// CoTask<> WpaSupplicant::WriteMessage(const std::string &message)
// {
//     co_await p2pSocket.CoWriteLine(message);
//     co_return;
// }

CoTask<> WpaSupplicant::ReadP2pMessages(std::function<void(void)> onClosed)
{
    co_await CoBackground();

    WpaEvent event;
    std::string line;
    try
    {
        while (true)
        {

            bool result = co_await p2pSocket.CoReadLine(&line);
            if (!result)
                break; // eof.

            if (traceMessages)
            {
                cout << "p: " << line << endl;
            }
            if (event.ParseLine(line.c_str()))
            {
                OnEvent(Source::P2p,event);
            }
        }
        Log().Error("p2p session terminated.");
    }
    catch (const std::exception &e)
    {
        Log().Error(SS("p2p session terminated. " << e.what()));
    }

    co_await CoForeground();
    if (onClosed)
    {
        onClosed();
    }

}

CoTask<> WpaSupplicant::ReadWlanMessages(std::function<void(void)> onClosed)
{
    co_await CoBackground();
    WpaEvent event;
    std::string line;
    try
    {
        while (true)
        {

            bool result = co_await wlanSocket.CoReadLine(&line);
            if (!result)
                break; // eof.

            if (traceMessages)
            {
                cout << "w: " << line << endl;
            }
            if (event.ParseLine(line.c_str()))
            {
                OnEvent(Source::Wlan,event);
            }
        }
        Log().Error("wlan session terminated.");
    }
    catch (const std::exception &e)
    {
        Log().Error(SS("p2p session terminated. " << e.what()));
    }
    co_await CoForeground();
    if (onClosed) {
        onClosed();
    }
}

CoTask<> WpaSupplicant::Run(int argc, const char *const *argv)
{
    try
    {
        this->traceMessages = true;

        vector<string> args;

        for (int i = 0; i < argc; ++i)
        {
            std::string arg = argv[i];
            if (arg == "--")
            {
                args.resize(0);
            }
            else if (arg == "--trace")
            {
                this->traceMessages = true;
            }
            else
            {
                args.push_back(argv[i]);
            }
        }

        std::filesystem::path socketDir{WPA_CONTROL_SOCKET_DIR};
        try
        {
            co_await p2pSocket.CoOpen(socketDir / this->p2pInterfaceName, CoFile::OpenMode::ReadWrite);
        }
        catch (const CoIoException &e)
        {
            throw CoIoException(e.errNo(), SS("Can't open control socket " << (socketDir / this->p2pInterfaceName) <<". " << e.what()));
        }

        try
        {
            co_await wlanSocket.CoOpen(socketDir / this->wlanInterfaceName, CoFile::OpenMode::ReadWrite);
        }
        catch (const CoIoException &e)
        {
            throw CoIoException(e.errNo(), SS("Can't open control socket " << (socketDir / this->wlanInterfaceName) <<". " << e.what()));
        }

        co_await CoOnInit();

        Dispatcher().StartThread(ReadWlanMessages(
            nullptr
            ));

        co_await ReadP2pMessages(nullptr);
    }
    catch (const std::exception &e)
    {
        Log().Error(e.what());
    }
    Dispatcher().PostQuit();

    co_return;
}

#ifdef JUNK
CoTask<std::vector<std::string>> WpaSupplicant::ReadToPrompt(std::chrono::milliseconds timeout)
{
    std::vector<std::string> response;
    while (true)
    {
        while (lineBufferHead != lineBufferTail)
        {
            char c = lineBuffer[lineBufferHead];
            if (c == '\n')
            {
                response.push_back(lineResult.str());
                lineResult.clear();
                lineResultEmpty = true;
            }
            else if (lineResultEmpty && c == '>')
            {
                if (lineBufferRecoveringFromTimeout)
                {
                    lineBufferRecoveringFromTimeout = true;
                    response.resize(0);
                }
                else
                {
                    NotifyPrompting();
                    co_return response;
                }
            }
            else
            {
                lineResultEmpty = false;
                lineResult << c;
            }
        }
        try
        {
            int nRead = co_await Stdin().CoRead(lineBuffer, sizeof(lineBuffer), timeout);
            lineBufferHead = 0;
            lineBufferTail = nRead;
        }
        catch (const CoTimedOutException &e)
        {
            lineBufferRecoveringFromTimeout = true;
            throw;
        }
    }
    co_return response;
}
#endif

void WpaSupplicant::Terminate() {
    Dispatcher().PostQuit();
}
